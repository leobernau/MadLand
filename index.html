<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>MadLand</title>
<style>
    body { margin:0; overflow:hidden; background:#88cc88; }
    canvas { display:block; background:#55aa55; }
    #ui { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; font-size:20px; }
    #upgradeMenu { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
                   background:rgba(0,0,0,0.8); padding:20px; display:none; border-radius:10px; color:white; }
    #gameOver { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
                background:rgba(0,0,0,0.8); padding:20px; display:none; border-radius:10px; color:white; text-align:center; }
    button { margin:5px; padding:10px; font-size:16px; }
    #xpBar { position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
             width:400px; height:20px; background:#333; border-radius:10px; overflow:hidden; }
    #xpFill { width:0%; height:100%; background:#ffdd00; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">Time: <span id="timer">45:00</span> | Health: <span id="health">100</span></div>
<div id="xpBar"><div id="xpFill"></div></div>
<div id="upgradeMenu">
    <div>Choose an Upgrade:</div>
    <button id="upg1"></button>
    <button id="upg2"></button>
    <button id="upg3"></button>
</div>
<div id="gameOver">
    <div>Game Over!</div>
    <button onclick="restartGame()">Restart</button>
</div>
<script>
// --- CANVAS SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- GLOBAL VARIABLES ---
let keys = {};
let player = {
    x: canvas.width/2,
    y: canvas.height/2,
    size:40,
    health:100,
    speed:5,
    dashCooldown:0,
    dashDuration:0,
    upgrades: []
};
let worldOffset = {x:0, y:0};
let monsters = [];
let projectiles = [];
let crystals = [];
let upgradesAvailable = [];
let timeLeft = 45*60; // in seconds
let xp = 0;
let xpToLevel = 10;
let level = 1;
let upgradeMenuVisible = false;
let gameOver = false;

// --- SOUNDS ---
const sounds = {
    shoot: new Audio('https://freesound.org/data/previews/320/320181_5260873-lq.mp3'),
    hit: new Audio('https://freesound.org/data/previews/174/174028_3247033-lq.mp3'),
    crystal: new Audio('https://freesound.org/data/previews/276/276020_5121236-lq.mp3'),
    dash: new Audio('https://freesound.org/data/previews/82/82355_1022653-lq.mp3'),
    levelUp: new Audio('https://freesound.org/data/previews/250/250629_4486188-lq.mp3')
};

// --- INPUT ---
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// --- MONSTER TYPES ---
const monsterTypes = [
    {name:'Orc', color:'#884422', size:40, health:20, speed:1.5, xp:2},
    {name:'Troll', color:'#225522', size:60, health:40, speed:1, xp:5},
    {name:'Dragon', color:'#aa2222', size:80, health:100, speed:0.8, xp:10},
    {name:'Witch', color:'#552288', size:50, health:30, speed:1.2, xp:4},
    {name:'Snake', color:'#22aa22', size:30, health:15, speed:2, xp:1}
];

// --- UPGRADES ---
const allUpgrades = [
    {name:'Bienen', desc:'Bienen greifen Gegner an', icon:'üêù', level:0, maxLevel:5},
    {name:'Heilung', desc:'Regeneriere alle 5 Sekunden', icon:'üíñ', level:0, maxLevel:5},
    {name:'Feuerball', desc:'Schie√üe Feuerb√§lle', icon:'üî•', level:0, maxLevel:5},
    {name:'Blitz', desc:'Schockt Gegner', icon:'‚ö°', level:0, maxLevel:5},
    {name:'Steinwurf', desc:'Wirft Steine auf Gegner', icon:'ü™®', level:0, maxLevel:5},
    {name:'Mini Golem', desc:'Ruft Helfer', icon:'üóø', level:0, maxLevel:5},
    {name:'Kristall Magnet', desc:'Zieht Kristalle an', icon:'üíé', level:0, maxLevel:5},
    {name:'Eis', desc:'Verlangsamt Gegner', icon:'‚ùÑÔ∏è', level:0, maxLevel:5}
];

// --- SPAWN MONSTERS ---
function spawnMonster() {
    const type = monsterTypes[Math.floor(Math.random()*monsterTypes.length)];
    const side = Math.floor(Math.random()*4);
    let x,y;
    if(side===0){ x=Math.random()*canvas.width; y=-type.size-10; }
    else if(side===1){ x=Math.random()*canvas.width; y=canvas.height+type.size+10; }
    else if(side===2){ x=-type.size-10; y=Math.random()*canvas.height; }
    else { x=canvas.width+type.size+10; y=Math.random()*canvas.height; }
    monsters.push({x:x-worldOffset.x, y:y-worldOffset.y, type:type, health:type.health});
}

// --- SPAWN CRYSTAL ---
function spawnCrystal(x,y) {
    const size = Math.random()<0.5?10:20;
    crystals.push({x:x, y:y, size:size});
}

// --- DRAW WORLD ---
function drawWorld() {
    ctx.fillStyle = '#228822';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // draw trees
    for(let i=-1000;i<1000;i+=200){
        for(let j=-1000;j<1000;j+=200){
            ctx.fillStyle='#8b5a2b';
            ctx.fillRect(i+worldOffset.x, j+worldOffset.y,20,60); // trunk
            ctx.beginPath();
            ctx.fillStyle='#228833';
            ctx.arc(i+worldOffset.x+10,j+worldOffset.y,30,0,Math.PI*2);
            ctx.fill();
        }
    }
    // draw crystals
    crystals.forEach(c=>{
        ctx.fillStyle='#00ffff';
        ctx.beginPath();
        ctx.moveTo(c.x+worldOffset.x, c.y+worldOffset.y-c.size);
        for(let i=0;i<5;i++){
            ctx.lineTo(c.x+worldOffset.x+c.size*Math.cos((18+i*72)*Math.PI/180),
                       c.y+worldOffset.y-c.size*Math.sin((18+i*72)*Math.PI/180));
        }
        ctx.fill();
    });
}

// --- DRAW PLAYER ---
function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle='blue';
    ctx.beginPath();
    ctx.arc(0,0,player.size/2,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle='white';
    ctx.fillRect(-5, -player.size/2,10,10); // face detail
    ctx.restore();
}

// --- DRAW MONSTERS ---
function drawMonsters() {
    monsters.forEach(m=>{
        ctx.fillStyle=m.type.color;
        ctx.beginPath();
        ctx.arc(m.x+worldOffset.x, m.y+worldOffset.y, m.type.size/2,0,Math.PI*2);
        ctx.fill();
        // health bar
        ctx.fillStyle='red';
        ctx.fillRect(m.x+worldOffset.x- m.type.size/2, m.y+worldOffset.y - m.type.size/2 -10,
                     m.type.size*(m.health/m.type.health),5);
    });
}

// --- DRAW PROJECTILES ---
function drawProjectiles() {
    ctx.fillStyle='yellow';
    projectiles.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p.x+worldOffset.x,p.y+worldOffset.y,5,0,Math.PI*2);
        ctx.fill();
    });
}

// --- UPDATE ---
function update() {
    if(gameOver || upgradeMenuVisible) return;

    // timer
    timeLeft -=1/60;
    if(timeLeft<=0){ gameOver=true; document.getElementById('gameOver').style.display='block'; }

    // movement
    let dx=0, dy=0;
    if(keys['w']) dy=-player.speed;
    if(keys['s']) dy=player.speed;
    if(keys['a']) dx=-player.speed;
    if(keys['d']) dx=player.speed;

    worldOffset.x -= dx;
    worldOffset.y -= dy;

    // dash
    if(keys[' '] && player.dashCooldown<=0){
        player.dashDuration=15;
        player.dashCooldown=60;
        sounds.dash.play();
    }
    if(player.dashDuration>0){
        worldOffset.x -= dx*3;
        worldOffset.y -= dy*3;
        player.dashDuration--;
    } else { if(player.dashCooldown>0) player.dashCooldown--; }

    // spawn monsters
    if(Math.random()<0.02) spawnMonster();

    // move monsters
    monsters.forEach(m=>{
        const mx = (m.x+worldOffset.x);
        const my = (m.y+worldOffset.y);
        const diffX = player.x - mx;
        const diffY = player.y - my;
        const dist = Math.sqrt(diffX*diffX+diffY*diffY);
        const speed = m.type.speed;
        m.x += (diffX/dist)*speed;
        m.y += (diffY/dist)*speed;
        // collision
        if(dist<player.size/2+m.type.size/2){
            player.health -=0.2;
        }
    });

    // projectiles
    projectiles.forEach((p,i)=>{
        p.x += p.vx;
        p.y += p.vy;
        // collision
        monsters.forEach((m,j)=>{
            const dx = (m.x+worldOffset.x) - (p.x+worldOffset.x);
            const dy = (m.y+worldOffset.y) - (p.y+worldOffset.y);
            const dist = Math.sqrt(dx*dx+dy*dy);
            if(dist<m.type.size/2){
                m.health -=10;
                projectiles.splice(i,1);
                sounds.hit.play();
                if(m.health<=0){
                    spawnCrystal(m.x+worldOffset.x, m.y+worldOffset.y);
                    xp+=m.type.xp;
                    monsters.splice(j,1);
                    if(xp>=xpToLevel){ xp-=xpToLevel; level++; showUpgradeMenu(); }
                }
            }
        });
    });

    // pickup crystals
    crystals.forEach((c,i)=>{
        const dx = player.x-(c.x+worldOffset.x);
        const dy = player.y-(c.y+worldOffset.y);
        const dist = Math.sqrt(dx*dx+dy*dy);
        if(dist<player.size/2+c.size){
            crystals.splice(i,1);
            sounds.crystal.play();
            xp +=1;
            if(xp>=xpToLevel){ xp-=xpToLevel; level++; showUpgradeMenu(); }
        }
    });

    document.getElementById('timer').innerText = Math.floor(timeLeft/60)+':'+('0'+Math.floor(timeLeft%60)).slice(-2);
    document.getElementById('health').innerText = Math.floor(player.health);
    document.getElementById('xpFill').style.width = (xp/xpToLevel*100)+'%';

    if(player.health<=0){ gameOver=true; document.getElementById('gameOver').style.display='block'; }
}

// --- DRAW ---
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawWorld();
    drawMonsters();
    drawProjectiles();
    drawPlayer();
}

// --- AUTO SHOOT ---
function autoShoot() {
    if(gameOver || upgradeMenuVisible) return;
    if(monsters.length>0){
        let target = monsters[0];
        let dx = target.x+worldOffset.x - player.x;
        let dy = target.y+worldOffset.y - player.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        projectiles.push({x:player.x, y:player.y, vx:dx/dist*10, vy:dy/dist*10});
        sounds.shoot.play();
    }
    setTimeout(autoShoot, 500);
}
autoShoot();

// --- UPGRADE MENU ---
function showUpgradeMenu(){
    upgradeMenuVisible=true;
    const menu = document.getElementById('upgradeMenu');
    menu.style.display='block';
    upgradesAvailable = [];
    for(let i=0;i<3;i++){
        let up = allUpgrades[Math.floor(Math.random()*allUpgrades.length)];
        upgradesAvailable.push(up);
    }
    document.getElementById('upg1').innerText=upgradesAvailable[0].icon+' '+upgradesAvailable[0].name;
    document.getElementById('upg2').innerText=upgradesAvailable[1].icon+' '+upgradesAvailable[1].name;
    document.getElementById('upg3').innerText=upgradesAvailable[2].icon+' '+upgradesAvailable[2].name;
}

// upgrade selection
document.getElementById('upg1').addEventListener('click',()=>{
    player.upgrades.push(upgradesAvailable[0]);
    upgradeMenuVisible=false;
    document.getElementById('upgradeMenu').style.display='none';
});
document.getElementById('upg2').addEventListener('click',()=>{
    player.upgrades.push(upgradesAvailable[1]);
    upgradeMenuVisible=false;
    document.getElementById('upgradeMenu').style.display='none';
});
document.getElementById('upg3').addEventListener('click',()=>{
    player.upgrades.push(upgradesAvailable[2]);
    upgradeMenuVisible=false;
    document.getElementById('upgradeMenu').style.display='none';
});

// --- RESTART ---
function restartGame(){
    player.health=100; xp=0; level=1; monsters=[]; crystals=[];
    worldOffset={x:0, y:0}; timeLeft=45*60; gameOver=false;
    document.getElementById('gameOver').style.display='none';
}

// --- GAME LOOP ---
function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
