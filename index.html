<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Epic Survival Game</title>
<style>
  body { margin:0; overflow:hidden; background:#87CEEB; }
  canvas { display:block; margin:0 auto; background:#4CAF50; }
  #upgradeMenu, #gameOverMenu {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.8); padding:20px; border-radius:15px; color:white;
    font-family:sans-serif; display:none; z-index:10; text-align:center;
  }
  button { margin:10px; padding:10px 20px; font-size:18px; border:none; border-radius:10px; cursor:pointer; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="upgradeMenu">
  <h2>Wähle ein Upgrade</h2>
  <div id="upgradeOptions"></div>
</div>

<div id="gameOverMenu">
  <h2>Game Over!</h2>
  <p id="gameOverText"></p>
  <button onclick="restartGame()">Neustarten</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

let keys = {};
let mouse = {x:0, y:0};
let lastDashTime = 0;
let dashCooldown = 1000;

let player = {
  x: width/2, y: height/2,
  size:40,
  hp:100,
  maxHp:100,
  speed:4,
  lastDirection:{x:0,y:-1},
  dashSpeed:15,
  dashDuration:200,
  dashing:false,
  dashStart:0
};

let monsters = [];
let projectiles = [];
let crystals = [];
let upgrades = [];
let gameTime = 45*60*1000;
let lastFrame = Date.now();
let score = 0;
let level = 1;
let gamePaused = false;
let gameOver = false;

// Farben & Assets
function drawGrass(x,y,w,h){
  ctx.fillStyle = "#3CB043";
  ctx.fillRect(x,y,w,h);
  for(let i=0;i<10;i++){
    ctx.fillStyle = "#2E8B57";
    ctx.beginPath();
    let gx = x + Math.random()*w;
    let gy = y + Math.random()*h;
    ctx.moveTo(gx,gy);
    ctx.lineTo(gx+2,gy-10);
    ctx.lineTo(gx+4,gy);
    ctx.fill();
  }
}

function drawTree(x,y){
  ctx.fillStyle="#8B4513";
  ctx.fillRect(x-5,y,10,40);
  ctx.fillStyle="#228B22";
  ctx.beginPath();
  ctx.arc(x,y,20,0,Math.PI*2);
  ctx.fill();
}

function drawRock(x,y){
  ctx.fillStyle="#808080";
  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.lineTo(x+15,y+5);
  ctx.lineTo(x+10,y+20);
  ctx.lineTo(x-5,y+15);
  ctx.fill();
}

// Spieler
function drawPlayer(p){
  ctx.save();
  ctx.translate(p.x,p.y);
  ctx.fillStyle="blue";
  ctx.beginPath();
  ctx.arc(0,0,p.size/2,0,Math.PI*2);
  ctx.fill();
  // Arme & Beine
  ctx.strokeStyle="black";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(0,-p.size/2); // Arm
  ctx.moveTo(0,0);
  ctx.lineTo(-p.size/4,p.size/2); // Bein
  ctx.moveTo(0,0);
  ctx.lineTo(p.size/4,p.size/2);
  ctx.stroke();
  ctx.restore();
}

// Healthbar
function drawHealth(x,y,hp,maxHp){
  ctx.fillStyle="red";
  ctx.fillRect(x-25,y-40,50,6);
  ctx.fillStyle="lime";
  ctx.fillRect(x-25,y-40,50*(hp/maxHp),6);
}

// Monster
class Monster{
  constructor(x,y,type){
    this.x = x;
    this.y = y;
    this.type = type;
    this.hp = 30 + Math.random()*20*level;
    this.maxHp = this.hp;
    this.size = 30 + Math.random()*20;
    this.speed = 1+Math.random()*1;
  }
  move(){
    let dx = player.x - this.x;
    let dy = player.y - this.y;
    let dist = Math.hypot(dx,dy);
    this.x += dx/dist*this.speed;
    this.y += dy/dist*this.speed;
  }
  draw(){
    ctx.fillStyle="purple";
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size/2,0,Math.PI*2);
    ctx.fill();
    drawHealth(this.x,this.y,this.hp,this.maxHp);
  }
}

// Projektil
class Projectile{
  constructor(x,y,target){
    this.x = x;
    this.y = y;
    this.target = target;
    this.speed = 10;
    this.size = 5;
  }
  update(){
    let dx = this.target.x - this.x;
    let dy = this.target.y - this.y;
    let dist = Math.hypot(dx,dy);
    this.x += dx/dist*this.speed;
    this.y += dy/dist*this.speed;
    if(dist<5){
      this.target.hp -= 10;
      if(this.target.hp<=0){
        spawnCrystal(this.target.x,this.target.y);
        monsters.splice(monsters.indexOf(this.target),1);
        score +=1;
      }
      projectiles.splice(projectiles.indexOf(this),1);
    }
  }
  draw(){
    ctx.fillStyle="yellow";
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
  }
}

// Kristall
function spawnCrystal(x,y){
  crystals.push({x:x,y:y,size:10+Math.random()*10});
}

function drawCrystal(c){
  ctx.fillStyle="cyan";
  ctx.beginPath();
  ctx.moveTo(c.x,c.y-c.size);
  ctx.lineTo(c.x+c.size/2,c.y+c.size/2);
  ctx.lineTo(c.x-c.size/2,c.y+c.size/2);
  ctx.closePath();
  ctx.fill();
}

// Steuerung
window.addEventListener("keydown",e=>{keys[e.key.toLowerCase()]=true;});
window.addEventListener("keyup",e=>{keys[e.key.toLowerCase()]=false;});
window.addEventListener("mousemove",e=>{mouse.x=e.clientX; mouse.y=e.clientY;});

// Dash
function tryDash(){
  let now = Date.now();
  if(now-lastDashTime>dashCooldown){
    lastDashTime = now;
    player.dashing = true;
    player.dashStart = now;
    player.lastDirection = {x:0,y:-1};
    if(keys['w']) player.lastDirection.y=-1;
    if(keys['s']) player.lastDirection.y=1;
    if(keys['a']) player.lastDirection.x=-1;
    if(keys['d']) player.lastDirection.x=1;
  }
}

// Upgrade Menü
function showUpgradeMenu(){
  gamePaused=true;
  let menu = document.getElementById("upgradeMenu");
  let optionsDiv = document.getElementById("upgradeOptions");
  optionsDiv.innerHTML = "";
  for(let i=0;i<3;i++){
    let btn = document.createElement("button");
    btn.innerText="Upgrade "+(i+1);
    btn.onclick=function(){
      gamePaused=false;
      menu.style.display="none";
    }
    optionsDiv.appendChild(btn);
  }
  menu.style.display="block";
}

// Game Over
function triggerGameOver(){
  gameOver=true;
  let menu = document.getElementById("gameOverMenu");
  document.getElementById("gameOverText").innerText="Dein Score: "+score;
  menu.style.display="block";
}

// Restart
function restartGame(){
  location.reload();
}

// Main Loop
function gameLoop(){
  let now = Date.now();
  let delta = now-lastFrame;
  lastFrame=now;
  if(!gamePaused && !gameOver){
    // Hintergrund
    ctx.clearRect(0,0,width,height);
    drawGrass(0,0,width,height);
    for(let i=0;i<10;i++) drawTree(Math.random()*width,Math.random()*height);
    for(let i=0;i<5;i++) drawRock(Math.random()*width,Math.random()*height);

    // Spieler Bewegung
    let dx=0, dy=0;
    if(keys['w']) dy=-player.speed;
    if(keys['s']) dy=player.speed;
    if(keys['a']) dx=-player.speed;
    if(keys['d']) dx=player.speed;
    player.x += dx;
    player.y += dy;

    // Dash
    if(player.dashing){
      player.x += player.lastDirection.x*player.dashSpeed;
      player.y += player.lastDirection.y*player.dashSpeed;
      if(now-player.dashStart>player.dashDuration) player.dashing=false;
    }

    // Monster Spawn
    if(monsters.length<10+level){
      monsters.push(new Monster(Math.random()*width,Math.random()*height,"orc"));
    }

    // Monster Update
    monsters.forEach(m=>m.move());
    // Collision Player-Monster
    monsters.forEach(m=>{
      let dist = Math.hypot(m.x-player.x, m.y-player.y);
      if(dist<m.size/2+player.size/2){
        player.hp -= 0.2;
        if(player.hp<=0) triggerGameOver();
      }
    });

    // Projektil Auto-Attack
    if(monsters.length>0 && now%500<delta){
      let closest = monsters.reduce((prev,curr)=>{
        let pd = Math.hypot(prev.x-player.x,prev.y-player.y);
        let cd = Math.hypot(curr.x-player.x,curr.y-player.y);
        return cd<pd?curr:prev;
      });
      projectiles.push(new Projectile(player.x,player.y,closest));
    }

    // Update Projektile
    projectiles.forEach(p=>p.update());

    // Draw Spieler
    drawPlayer(player);
    drawHealth(player.x,player.y,player.hp,player.maxHp);

    // Draw Monster
    monsters.forEach(m=>m.draw());

    // Draw Projektile
    projectiles.forEach(p=>p.draw());

    // Draw Kristalle
    crystals.forEach(c=>drawCrystal(c));

    // Timer
    gameTime -= delta;
    ctx.fillStyle="white";
    ctx.font="40px sans-serif";
    let minutes = Math.floor(gameTime/60000);
    let seconds = Math.floor((gameTime%60000)/1000);
    ctx.fillText(minutes.toString().padStart(2,'0')+":"+seconds.toString().padStart(2,'0'),width/2-50,50);
    if(gameTime<=0) triggerGameOver();
  }
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
