<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>MadLand</title>
<style>
body { margin:0; overflow:hidden; background:#3cb043; font-family:sans-serif; }
canvas { display:block; margin:0 auto; }
#ui { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; }
#timer { position:absolute; top:20px; left:50%; transform:translateX(-50%); font-size:36px; font-weight:bold; color:white; text-shadow:1px 1px black; }
#crystalBarContainer { position:absolute; bottom:20px; left:50%; transform:translateX(-50%); width:400px; height:30px; background:black; border:2px solid white; border-radius:8px; }
#crystalBar { width:0%; height:100%; background:cyan; border-radius:6px; }
#gameOverMenu, #upgradeMenu { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); display:none; justify-content:center; align-items:center; flex-direction:column; color:white; font-size:24px; }
button { font-size:20px; margin:10px; padding:10px 20px; cursor:pointer; }
#upgradeIcons { position:absolute; bottom:70px; left:50%; transform:translateX(-50%); display:flex; gap:10px; }
.upgradeIcon { width:50px; height:50px; background:#fff; border:2px solid #000; border-radius:8px; display:flex; justify-content:center; align-items:center; font-weight:bold; font-size:18px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="ui">
  <div id="timer">45:00</div>
  <div id="upgradeIcons"></div>
  <div id="crystalBarContainer"><div id="crystalBar"></div></div>
</div>
<div id="gameOverMenu">
  <div>Game Over!</div>
  <button onclick="restartGame()">Restart</button>
</div>
<div id="upgradeMenu">
  <div>WÃ¤hle ein Upgrade:</div>
  <div id="upgradeOptions" style="display:flex; gap:20px; margin-top:20px;"></div>
</div>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
let cw=canvas.width=window.innerWidth;
let ch=canvas.height=window.innerHeight;
window.addEventListener('resize',()=>{cw=canvas.width=window.innerWidth; ch=canvas.height=window.innerHeight;});

const keys={};
document.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
document.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

let gameOver=false;
let upgradeMenuActive=false;
let upgrades=[];
const upgradeIconsDiv=document.getElementById('upgradeIcons');

let timer=45*60;

let crystals=0;
let crystalsForNextLevel=10;

// Player
const player={
  x:cw/2,
  y:ch/2,
  size:30,
  speed:4,
  dashSpeed:10,
  dashCooldown:0,
  dashDir:{x:0,y:0},
  hp:100,
  maxHp:100,
  shootCooldown:0,
  lastDir:{x:0,y:0}
};

// World
let worldOffset={x:0,y:0};
const worldObjects=[];
for(let i=0;i<300;i++){
  worldObjects.push({x:Math.random()*6000-3000, y:Math.random()*6000-3000, type:Math.random()<0.6?'tree':'rock'});
}

// Monsters
class Monster{
  constructor(x,y){
    this.x=x; this.y=y; this.size=30; this.hp=50; this.maxHp=50; this.speed=1+Math.random(); this.alive=true;
  }
  update(){
    if(!this.alive) return;
    let dx=player.x-(this.x-worldOffset.x);
    let dy=player.y-(this.y-worldOffset.y);
    let dist=Math.sqrt(dx*dx+dy*dy);
    this.x+=(dx/dist)*this.speed;
    this.y+=(dy/dist)*this.speed;
    if(dist<this.size+player.size){
      player.hp-=0.5;
      if(player.hp<=0){ gameOver=true; document.getElementById('gameOverMenu').style.display='flex'; }
    }
  }
  draw(){
    if(!this.alive) return;
    ctx.fillStyle='darkred';
    ctx.beginPath();
    ctx.ellipse(this.x-worldOffset.x,this.y-worldOffset.y,this.size,this.size*0.7,0,0,Math.PI*2);
    ctx.fill();
    // Healthbar
    ctx.fillStyle='black';
    ctx.fillRect(this.x-20-worldOffset.x,this.y-45-worldOffset.y,40,5);
    ctx.fillStyle='lime';
    ctx.fillRect(this.x-20-worldOffset.x,this.y-45-worldOffset.y,40*(this.hp/this.maxHp),5);
  }
}
const monsters=[];
function spawnMonster(){
  const x=Math.random()*2000-1000+worldOffset.x;
  const y=Math.random()*2000-1000+worldOffset.y;
  monsters.push(new Monster(x,y));
}
setInterval(spawnMonster,2000);

// Projectiles
class Projectile{
  constructor(x,y,target){
    this.x=x; this.y=y; this.target=target; this.speed=8; this.alive=true;
  }
  update(){
    if(!this.alive||!this.target.alive){ this.alive=false; return; }
    let dx=this.target.x-this.x;
    let dy=this.target.y-this.y;
    let dist=Math.sqrt(dx*dx+dy*dy);
    this.x+=(dx/dist)*this.speed;
    this.y+=(dy/dist)*this.speed;
    if(dist<10){
      this.target.hp-=10;
      this.alive=false;
      if(this.target.hp<=0){
        this.target.alive=false;
        // Crystal drop
        crystals++;
        if(crystals>=crystalsForNextLevel){
          crystals=0;
          showUpgradeMenu();
        }
      }
    }
  }
  draw(){
    if(!this.alive) return;
    ctx.fillStyle='yellow';
    ctx.beginPath();
    ctx.arc(this.x-worldOffset.x,this.y-worldOffset.y,5,0,Math.PI*2);
    ctx.fill();
  }
}
const projectiles=[];

// Auto Shooting
let shootTimer=0;
function handleShooting(){
  shootTimer--;
  if(shootTimer<=0){
    shootTimer=30;
    let nearest=null; let ndist=99999;
    monsters.forEach(m=>{
      if(m.alive){
        let dx=m.x-worldOffset.x-player.x;
        let dy=m.y-worldOffset.y-player.y;
        let d=Math.sqrt(dx*dx+dy*dy);
        if(d<ndist){ ndist=d; nearest=m;}
      }
    });
    if(nearest) projectiles.push(new Projectile(player.x,player.y,nearest));
  }
}

// Dash
function handleDash(){
  if(keys[' '] && player.dashCooldown<=0){
    player.dashCooldown=20;
    player.dashDir={...player.lastDir};
    if(player.dashDir.x===0 && player.dashDir.y===0) player.dashDir={x:0,y:-1};
  }
  if(player.dashCooldown>0){
    worldOffset.x-=player.dashDir.x*player.dashSpeed;
    worldOffset.y-=player.dashDir.y*player.dashSpeed;
    player.dashCooldown--;
  }
}

// Movement
function handleMovement(){
  let dir={x:0,y:0};
  if(keys['w']) dir.y=-1;
  if(keys['s']) dir.y=1;
  if(keys['a']) dir.x=-1;
  if(keys['d']) dir.x=1;
  if(dir.x!==0 || dir.y!==0){
    let len=Math.sqrt(dir.x*dir.x + dir.y*dir.y);
    dir.x/=len; dir.y/=len;
    worldOffset.x-=dir.x*player.speed;
    worldOffset.y-=dir.y*player.speed;
    player.lastDir={...dir};
  }
}

// Upgrades
const allUpgrades=[{name:'Bienen',level:0},{name:'Heilung',level:0},{name:'Feuerball',level:0}];
function showUpgradeMenu(){
  upgradeMenuActive=true;
  document.getElementById('upgradeMenu').style.display='flex';
  const container=document.getElementById('upgradeOptions');
  container.innerHTML='';
  let options=[];
  while(options.length<3){
    let u=allUpgrades[Math.floor(Math.random()*allUpgrades.length)];
    if(!options.includes(u)) options.push(u);
  }
  options.forEach(u=>{
    const btn=document.createElement('button');
    btn.innerText=u.name;
    btn.onclick=()=>{
      u.level++;
      upgrades.push(u.name);
      updateUpgradeIcons();
      upgradeMenuActive=false;
      document.getElementById('upgradeMenu').style.display='none';
    };
    container.appendChild(btn);
  });
}
function updateUpgradeIcons(){
  upgradeIconsDiv.innerHTML='';
  upgrades.forEach(u=>{
    const div=document.createElement('div');
    div.className='upgradeIcon';
    div.innerText=u[0];
    upgradeIconsDiv.appendChild(div);
  });
}

// Timer
function updateTimer(){
  if(gameOver || upgradeMenuActive) return;
  timer-=1/60;
  let min=Math.floor(timer/60);
  let sec=Math.floor(timer%60);
  document.getElementById('timer').innerText=`${min.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
  if(timer<=0){ gameOver=true; document.getElementById('gameOverMenu').style.display='flex'; }
}

// Crystal Bar
function updateCrystalBar(){
  document.getElementById('crystalBar').style.width=Math.min(100,crystals/crystalsForNextLevel*100)+'%';
}

// Game Loop
function gameLoop(){
  ctx.clearRect(0,0,cw,ch);
  if(gameOver) return;

  handleMovement();
  handleDash();
  handleShooting();
  updateTimer();
  updateCrystalBar();

  // Draw world
  worldObjects.forEach(o=>{
    if(o.type==='tree'){
      ctx.fillStyle='sienna';
      ctx.fillRect(o.x-worldOffset.x-5,o.y-worldOffset.y,10,20);
      ctx.fillStyle='green';
      ctx.beginPath();
      ctx.arc(o.x-worldOffset.x,o.y-10-worldOffset.y,15,0,Math.PI*2);
      ctx.fill();
    }else{
      ctx.fillStyle='gray';
      ctx.beginPath();
      ctx.arc(o.x-worldOffset.x,o.y-worldOffset.y,10,0,Math.PI*2);
      ctx.fill();
    }
  });

  monsters.forEach(m=>{ m.update(); m.draw(); });
  projectiles.forEach(p=>{ p.update(); p.draw(); });

  // Player
  ctx.fillStyle='blue';
  ctx.beginPath();
  ctx.ellipse(player.x,player.y,20,30,0,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle='peachpuff';
  ctx.beginPath();
  ctx.arc(player.x,player.y-30,10,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle='black';
  ctx.fillRect(player.x-50,player.y+50,100,10);
  ctx.fillStyle='lime';
  ctx.fillRect(player.x-50,player.y+50,100*(player.hp/player.maxHp),10);

  requestAnimationFrame(gameLoop);
}
gameLoop();

function restartGame(){
  player.hp=player.maxHp;
  monsters.forEach(m=>m.alive=true);
  crystals=0;
  gameOver=false;
  timer=45*60;
  document.getElementById('gameOverMenu').style.display='none';
}
</script>
</body>
</html>
