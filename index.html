<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Epic Survival Game</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; background:#000;
  }
  canvas {
    display:block; background: #87ceeb; /* Himmelblau */
  }
  #ui {
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    color:white; font-family:sans-serif; font-size:32px; text-shadow:2px 2px 5px black;
  }
  #upgradeMenu, #gameOverMenu {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.8); color:white; font-family:sans-serif; display:flex;
    flex-direction:column; align-items:center; justify-content:center; font-size:24px;
    display:none;
  }
  .upgradeOption {
    margin:10px; padding:10px 20px; border:2px solid white; cursor:pointer; transition:all 0.3s;
  }
  .upgradeOption:hover {
    background:white; color:black;
  }
  #restartButton {
    margin-top:20px; padding:10px 20px; border:2px solid white; cursor:pointer;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">45:00</div>
<div id="upgradeMenu">
  <div>Wähle ein Upgrade:</div>
  <div id="upgradeOptions"></div>
</div>
<div id="gameOverMenu">
  <div>GAME OVER</div>
  <div id="easterEgg" style="margin:10px; font-size:16px;">✨</div>
  <div id="restartButton">Neustart</div>
</div>

<script>
/* -------------------
  GAME INITIALIZATION
------------------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let cw = canvas.width = window.innerWidth;
let ch = canvas.height = window.innerHeight;

window.addEventListener('resize', ()=>{
  cw = canvas.width = window.innerWidth;
  ch = canvas.height = window.innerHeight;
});

/* -------------------
  GAME VARIABLES
------------------- */
let keys = {};
let player = {
  x: cw/2, y: ch/2, size:50, speed:5, health:100, maxHealth:100,
  lastDir:{x:0,y:-1}, dashCooldown:0
};
let monsters = [];
let bullets = [];
let particles = [];
let upgrades = [];
let crystals = [];
let score = 0;
let level = 1;
let upgradePoints = 0;
let timeLeft = 45*60; // in seconds
let gamePaused = false;
let gameOver = false;

/* -------------------
  EVENT LISTENERS
------------------- */
document.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()]=true;
});
document.addEventListener('keyup', e=>{
  keys[e.key.toLowerCase()]=false;
});
document.getElementById("restartButton").addEventListener('click', ()=>{
  restartGame();
});

/* -------------------
  HELPER FUNCTIONS
------------------- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function distance(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

/* -------------------
  SPRITE DRAW FUNCTIONS
------------------- */
function drawPlayer(){
  ctx.save();
  ctx.translate(player.x,player.y);
  // Körper
  ctx.fillStyle="#ffcc00";
  ctx.beginPath();
  ctx.ellipse(0,0,20,30,0,0,Math.PI*2);
  ctx.fill();
  // Kopf
  ctx.fillStyle="#ffe0b3";
  ctx.beginPath();
  ctx.arc(0,-35,15,0,Math.PI*2);
  ctx.fill();
  // Arme
  ctx.strokeStyle="#ffe0b3"; ctx.lineWidth=6;
  ctx.beginPath(); ctx.moveTo(-15,0); ctx.lineTo(-25,15); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(15,0); ctx.lineTo(25,15); ctx.stroke();
  // Beine
  ctx.beginPath(); ctx.moveTo(-10,30); ctx.lineTo(-15,45); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(10,30); ctx.lineTo(15,45); ctx.stroke();
  ctx.restore();
}

function drawMonster(mon){
  ctx.save();
  ctx.translate(mon.x,mon.y);
  // Körper
  ctx.fillStyle=mon.color;
  ctx.beginPath();
  ctx.ellipse(0,0,mon.sizeX,mon.sizeY,0,0,Math.PI*2);
  ctx.fill();
  // Healthbar
  ctx.fillStyle="red";
  ctx.fillRect(-mon.sizeX,-mon.sizeY-10,mon.sizeX*2*(mon.health/mon.maxHealth),5);
  ctx.strokeStyle="black";
  ctx.strokeRect(-mon.sizeX,-mon.sizeY-10,mon.sizeX*2,5);
  ctx.restore();
}

function drawCrystal(cr){
  ctx.save();
  ctx.translate(cr.x,cr.y);
  ctx.fillStyle=cr.color;
  ctx.beginPath();
  ctx.moveTo(0,-10); ctx.lineTo(5,0); ctx.lineTo(0,10); ctx.lineTo(-5,0); ctx.closePath();
  ctx.fill();
  ctx.restore();
}

/* -------------------
  GAME LOOP
------------------- */
let lastTime=0;
function gameLoop(ts){
  const delta=(ts-lastTime)/16.666; // ~60fps
  lastTime=ts;
  if(!gamePaused && !gameOver){
    update(delta);
    draw();
  }
  requestAnimationFrame(gameLoop);
}

function update(delta){
  handlePlayer(delta);
  handleMonsters(delta);
  handleBullets(delta);
  handleCrystals(delta);
  updateTimer(delta);
  handleParticles(delta);
}

function draw(){
  ctx.clearRect(0,0,cw,ch);
  drawWorld();
  drawCrystals();
  drawPlayer();
  drawMonsters();
  drawBullets();
  drawParticles();
  drawUI();
}

/* -------------------
  WORLD
------------------- */
function drawWorld(){
  // Grasboden
  ctx.fillStyle="#228B22";
  ctx.fillRect(0,0,cw,ch);
  // Bäume zufällig
  for(let i=0;i<20;i++){
    let tx=(i*50+50)%cw;
    let ty=(i*80+30)%ch;
    ctx.fillStyle="#8B4513";
    ctx.fillRect(tx-5,ty,10,30);
    ctx.fillStyle="#006400";
    ctx.beginPath();
    ctx.moveTo(tx-25,ty); ctx.lineTo(tx+25,ty); ctx.lineTo(tx,ty-40); ctx.closePath();
    ctx.fill();
  }
}

/* -------------------
  PLAYER
------------------- */
function handlePlayer(delta){
  let dx=0,dy=0;
  if(keys['w']){ dy=-1; player.lastDir.y=-1; player.lastDir.x=0; }
  if(keys['s']){ dy=1; player.lastDir.y=1; player.lastDir.x=0; }
  if(keys['a']){ dx=-1; player.lastDir.x=-1; player.lastDir.y=0; }
  if(keys['d']){ dx=1; player.lastDir.x=1; player.lastDir.y=0; }
  player.x+=dx*player.speed*delta;
  player.y+=dy*player.speed*delta;
  player.x=clamp(player.x,50,cw-50);
  player.y=clamp(player.y,50,ch-50);

  // Dash
  if(keys[' ']){
    if(player.dashCooldown<=0){
      player.x+=player.lastDir.x*20*delta;
      player.y+=player.lastDir.y*20*delta;
      player.dashCooldown=60; // 1s Cooldown ~60 frames
    }
  }
  if(player.dashCooldown>0) player.dashCooldown-=delta;
}

/* -------------------
  MONSTERS
------------------- */
function handleMonsters(delta){
  // Spawn zufällig
  if(monsters.length<10+level){
    if(Math.random()<0.02){
      spawnMonster();
    }
  }
  monsters.forEach(mon=>{
    let angle=Math.atan2(player.y-mon.y,player.x-mon.x);
    mon.x+=Math.cos(angle)*mon.speed*delta;
    mon.y+=Math.sin(angle)*mon.speed*delta;
    // Collision mit Player
    if(distance(mon,player)<30){
      player.health-=0.2*delta;
      if(player.health<=0){ gameOver=true; showGameOver(); }
    }
  });
}
function spawnMonster(){
  let monTypes=[
    {sizeX:20,sizeY:30,color:"purple",speed:1,health:30,maxHealth:30},
    {sizeX:25,sizeY:25,color:"green",speed:1.5,health:40,maxHealth:40},
    {sizeX:30,sizeY:40,color:"red",speed:0.8,health:60,maxHealth:60}
  ];
  let type=monTypes[Math.floor(Math.random()*monTypes.length)];
  let m={
    x:Math.random()*cw,
    y:Math.random()*ch,
    ...type
  };
  monsters.push(m);
}
function drawMonsters(){monsters.forEach(drawMonster);}

/* -------------------
  BULLETS
------------------- */
function handleBullets(delta){
  bullets.forEach((b,i)=>{
    b.x+=b.vx*delta;
    b.y+=b.vy*delta;
    // Hit detection
    monsters.forEach((m,j)=>{
      if(distance(b,m)<20){
        m.health-=b.damage;
        particles.push({x:b.x,y:b.y,life:20,r:3,color:"yellow"});
        bullets.splice(i,1);
      }
    });
  });
  bullets = bullets.filter(b=>b.x>0 && b.x<cw && b.y>0 && b.y<ch);
}

function drawBullets(){
  bullets.forEach(b=>{
    ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,5,0,Math.PI*2); ctx.fill();
  });
}

// Auto-shoot every 0.5s
let shootTimer=0;
function autoShoot(delta){
  shootTimer-=delta;
  if(shootTimer<=0){
    if(monsters.length>0){
      let target=monsters[0];
      let angle=Math.atan2(target.y-player.y,target.x-player.x);
      bullets.push({
        x:player.x, y:player.y,
        vx:Math.cos(angle)*10, vy:Math.sin(angle)*10,
        damage:10, color:"cyan"
      });
      shootTimer=30; // ~0.5s
    }
  }
}

/* -------------------
  CRYSTALS
------------------- */
function handleCrystals(delta){
  crystals.forEach((cr,i)=>{
    if(distance(cr,player)<30){
      crystals.splice(i,1);
      score+=cr.value;
      upgradePoints+=1;
    }
  });
}
function drawCrystals(){crystals.forEach(drawCrystal);}

/* -------------------
  PARTICLES
------------------- */
function handleParticles(delta){
  particles.forEach((p,i)=>{
    p.life-=delta;
    p.x+=rand(-1,1)*delta; p.y+=rand(-1,1)*delta;
  });
  particles = particles.filter(p=>p.life>0);
}
function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
  });
}

/* -------------------
  TIMER & UI
------------------- */
function updateTimer(delta){
  timeLeft-=delta/60;
  if(timeLeft<=0){ gamePaused=true; alert("Du hast gewonnen!"); }
}
function drawUI(){
  const ui = document.getElementById("ui");
  let min=Math.floor(timeLeft/60);
  let sec=Math.floor(timeLeft%60);
  ui.textContent=`${String(min).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  // Healthbar
  ctx.fillStyle="red";
  ctx.fillRect(50,20,200*(player.health/player.maxHealth),20);
  ctx.strokeStyle="white";
  ctx.strokeRect(50,20,200,20);
}

/* -------------------
  GAME OVER & UPGRADE MENU
------------------- */
function showGameOver(){
  document.getElementById("gameOverMenu").style.display="flex";
}
function restartGame(){
  player.health=player.maxHealth;
  monsters=[]; bullets=[]; particles=[]; crystals=[]; score=0; level=1; upgradePoints=0; timeLeft=45*60;
  gamePaused=false; gameOver=false;
  document.getElementById("gameOverMenu").style.display="none";
}

/* -------------------
  MAIN LOOP START
------------------- */
setInterval(()=>{ if(!gamePaused&&!gameOver) autoShoot(1); },16);
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
