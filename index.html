<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>MadLand</title>
<style>
body { margin:0; overflow:hidden; background:#55aa55; }
canvas { display:block; background:#228822; }
#ui { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; font-size:20px; }
#xpBar { position:absolute; bottom:10px; left:50%; transform:translateX(-50%);
         width:400px; height:20px; background:#333; border-radius:10px; overflow:hidden; }
#xpFill { width:0%; height:100%; background:#ffdd00; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">Time: <span id="timer">45:00</span> | Health: <span id="health">100</span></div>
<div id="xpBar"><div id="xpFill"></div></div>
<script>
// ---------------- SETUP ----------------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
let player = { x:canvas.width/2, y:canvas.height/2, size:40, health:100, speed:5,
               dashCooldown:0, dashDuration:0, upgrades:[], healTimer:0 };
let worldOffset = {x:0, y:0};
let monsters = [];
let projectiles = [];
let crystals = [];
let timeLeft = 45*60;
let xp = 0;
let xpToLevel = 10;
let level = 1;
let upgradeMenuVisible = false;

window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

// ---------------- MONSTER TYPES ----------------
const monsterTypes = [
    {name:'Orc', color:'#884422', size:40, health:20, speed:1.5, xp:2},
    {name:'Troll', color:'#225522', size:60, health:40, speed:1, xp:5},
    {name:'Dragon', color:'#aa2222', size:80, health:100, speed:0.8, xp:10}
];

// ---------------- UPGRADE TYPES ----------------
const allUpgrades = [
    {name:'Bienen', effect:(p,m)=>{ /* damage nearby monsters */ 
        monsters.forEach(mon=>{
            const dx=mon.x+worldOffset.x - player.x; const dy=mon.y+worldOffset.y - player.y;
            const dist=Math.sqrt(dx*dx+dy*dy); if(dist<100) mon.health -=0.5;
        });
    }},
    {name:'Heilung', effect:(p,m)=>{ p.healTimer++; if(p.healTimer>300){ p.health+=1; p.healTimer=0; }}},
    {name:'Feuerball', effect:(p,m)=>{/* shoot additional projectile */
        if(Math.random()<0.01){
            if(monsters.length>0){
                let target=monsters[0];
                let dx=target.x+worldOffset.x-player.x;
                let dy=target.y+worldOffset.y-player.y;
                let dist=Math.sqrt(dx*dx+dy*dy);
                projectiles.push({x:player.x, y:player.y, vx:dx/dist*8, vy:dy/dist*8});
            }
        }
    }},
    {name:'Kristall Magnet', effect:(p,m)=>{ crystals.forEach(c=>{ c.x += (player.x-(c.x+worldOffset.x))*0.05;
                                                                   c.y += (player.y-(c.y+worldOffset.y))*0.05; });}}
];

// ---------------- SPAWN MONSTER ----------------
function spawnMonster() {
    const type=monsterTypes[Math.floor(Math.random()*monsterTypes.length)];
    const side=Math.floor(Math.random()*4);
    let x,y;
    if(side===0){ x=Math.random()*canvas.width; y=-type.size-10; }
    else if(side===1){ x=Math.random()*canvas.width; y=canvas.height+type.size+10; }
    else if(side===2){ x=-type.size-10; y=Math.random()*canvas.height; }
    else { x=canvas.width+type.size+10; y=Math.random()*canvas.height; }
    monsters.push({x:x-worldOffset.x, y:y-worldOffset.y, type:type, health:type.health});
}

// ---------------- SPAWN CRYSTAL ----------------
function spawnCrystal(x,y) {
    const size = Math.random()<0.5?10:20;
    crystals.push({x:x, y:y, size:size});
}

// ---------------- DRAW WORLD ----------------
function drawWorld() {
    ctx.fillStyle='#228822'; ctx.fillRect(0,0,canvas.width,canvas.height);
    // trees
    for(let i=-1000;i<1000;i+=200){
        for(let j=-1000;j<1000;j+=200){
            ctx.fillStyle='#8b5a2b'; ctx.fillRect(i+worldOffset.x,j+worldOffset.y,20,60);
            ctx.fillStyle='#228833'; ctx.beginPath();
            ctx.arc(i+worldOffset.x+10,j+worldOffset.y,30,0,Math.PI*2); ctx.fill();
        }
    }
    // crystals
    crystals.forEach(c=>{
        ctx.fillStyle='#00ffff'; ctx.beginPath();
        ctx.moveTo(c.x+worldOffset.x, c.y+worldOffset.y-c.size);
        for(let i=0;i<5;i++){
            ctx.lineTo(c.x+worldOffset.x+c.size*Math.cos((18+i*72)*Math.PI/180),
                       c.y+worldOffset.y-c.size*Math.sin((18+i*72)*Math.PI/180));
        }
        ctx.fill();
    });
}

// ---------------- DRAW PLAYER ----------------
function drawPlayer() {
    ctx.save(); ctx.translate(player.x,player.y);
    ctx.fillStyle='blue'; ctx.beginPath(); ctx.arc(0,0,player.size/2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='white'; ctx.fillRect(-5,-player.size/2,10,10);
    ctx.restore();
}

// ---------------- DRAW MONSTERS ----------------
function drawMonsters() {
    monsters.forEach(m=>{
        ctx.fillStyle=m.type.color;
        ctx.beginPath(); ctx.arc(m.x+worldOffset.x, m.y+worldOffset.y, m.type.size/2,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='red';
        ctx.fillRect(m.x+worldOffset.x- m.type.size/2, m.y+worldOffset.y - m.type.size/2 -10,
                     m.type.size*(m.health/m.type.health),5);
    });
}

// ---------------- DRAW PROJECTILES ----------------
function drawProjectiles() {
    ctx.fillStyle='yellow';
    projectiles.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x+worldOffset.x,p.y+worldOffset.y,5,0,Math.PI*2); ctx.fill(); });
}

// ---------------- UPDATE ----------------
function update() {
    if(player.health<=0) return;

    // timer
    timeLeft -=1/60; if(timeLeft<=0) player.health=0;

    // movement
    let dx=0, dy=0;
    if(keys['w']) dy=-player.speed; if(keys['s']) dy=player.speed;
    if(keys['a']) dx=-player.speed; if(keys['d']) dx=player.speed;
    worldOffset.x -= dx; worldOffset.y -= dy;

    // dash
    if(keys[' '] && player.dashCooldown<=0){ player.dashDuration=15; player.dashCooldown=60; }
    if(player.dashDuration>0){ worldOffset.x -= dx*3; worldOffset.y -= dy*3; player.dashDuration--; }
    else { if(player.dashCooldown>0) player.dashCooldown--; }

    // spawn monsters
    if(Math.random()<0.02) spawnMonster();

    // monsters move
    monsters.forEach((m,j)=>{
        const dxm = (m.x+worldOffset.x)-player.x; const dym = (m.y+worldOffset.y)-player.y;
        const dist=Math.sqrt(dxm*dxm+dym*dym);
        m.x -= dxm/dist*m.type.speed; m.y -= dym/dist*m.type.speed;
        if(dist<player.size/2+m.type.size/2){ player.health -=0.2; }
    });

    // projectiles
    projectiles.forEach((p,i)=>{
        p.x += p.vx; p.y += p.vy;
        monsters.forEach((m,j)=>{
            const dxm=(m.x+worldOffset.x)-(p.x+worldOffset.x);
            const dym=(m.y+worldOffset.y)-(p.y+worldOffset.y);
            const dist=Math.sqrt(dxm*dxm+dym*dym);
            if(dist<m.type.size/2){ m.health -=10; projectiles.splice(i,1);
                if(m.health<=0){ spawnCrystal(m.x+worldOffset.x,m.y+worldOffset.y); xp+=m.type.xp; monsters.splice(j,1); }
            }
        });
    });

    // pickup crystals
    crystals.forEach((c,i)=>{
        const dx = player.x-(c.x+worldOffset.x); const dy = player.y-(c.y+worldOffset.y);
        const dist = Math.sqrt(dx*dx+dy*dy);
        if(dist<player.size/2+c.size){ crystals.splice(i,1); xp++; }
    });

    // apply upgrades
    player.upgrades.forEach(u=>{ u.effect(player,monsters); });

    document.getElementById('timer').innerText = Math.floor(timeLeft/60)+':'+('0'+Math.floor(timeLeft%60)).slice(-2);
    document.getElementById('health').innerText = Math.floor(player.health);
    document.getElementById('xpFill').style.width = (xp/xpToLevel*100)+'%';

    if(xp>=xpToLevel){ xp-=xpToLevel; level++; assignUpgrade(); }
}

// ---------------- ASSIGN UPGRADE ----------------
function assignUpgrade(){
    const newUp = allUpgrades[Math.floor(Math.random()*allUpgrades.length)];
    player.upgrades.push(newUp);
}

// ---------------- DRAW ----------------
function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawWorld(); drawMonsters(); drawProjectiles(); drawPlayer();
}

// ---------------- AUTO SHOOT ----------------
function autoShoot(){
    if(player.health<=0) return;
    if(monsters.length>0){
        let target = monsters[0];
        let dx = target.x+worldOffset.x-player.x; let dy = target.y+worldOffset.y-player.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        projectiles.push({x:player.x, y:player.y, vx:dx/dist*10, vy:dy/dist*10});
    }
    setTimeout(autoShoot, 500);
}
autoShoot();

// ---------------- GAME LOOP ----------------
function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
